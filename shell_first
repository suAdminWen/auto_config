#!/bin/bash

echo "# --------------------------------------------------- #"
echo "# 输出echo"
echo "# --------------------------------------------------- #"

echo "# -e 开启转义---------------------------------------- #"
echo ""
echo -e "ok,这里要换个行，\n我下一行了"
echo "ok \n这里没哟换行"
echo 'ok,这样也是不换行的，\n信不信'
# 显示执行结果
echo `date`

# --------------------------------------------------- #"
# 变量
# --------------------------------------------------- #"

# 变量名=赋值  等于号前后没有空格"
user=$USER

echo '# $变量名  对于已经定义的变量，前面加上 `$` 即可使用'
echo -e $user
echo -e ${user}  # 带上花括号的输入结果相同，但是可以帮助解释器识别边界

# 只读变量

wen="wangzhiwen"
readonly wen

# 删除变量
aa="12"
unset aa
echo -e $aa  # 这里没有输出

# 变量被删除后不能再次使用。unset 命令不能删除只读变量。

# --------------------------------------------------- #
# 字符串
# 单引号和双引号都可以用来标识字符串，或者不用也可以，但是单引号和双引号有以下区别
# 1、单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的
# 2、单引号中不能出现一个单引号，即使转义符后也不行，但是可以成对出现，作为字符串拼接使用
# --------------------------------------------------- #

echo -e "$USER"
echo -e '$USER'

# 获取字符串长度

string="wrttyyu"
echo "计算字符串长度：${#string}"

# 截取字符串

echo "字符串截取：${string:1:3}"


# --------------------------------------------------- #
# 数组
# bash支持一维数组（不支持多维数组），并且没有限定数组的大小。
# 类似与 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0
# --------------------------------------------------- #

# 数组名=(值1 值2 值3 ... 值n)
array=(1 2 3)

# 读取数组 使用`@`符号可以获取数组中的所有元素
echo -e "数组中全部元素：${array[@]}"
# 获取数组的长度
echo -e "数组的长度：${#array[@]}"
echo -e "数组中索引为1的值：${array[1]}"

# --------------------------------------------------- #
# 参数传入
# 向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……
# --------------------------------------------------- #

# --------------------------------------------------- #
# 基本运算符
# 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。
# --------------------------------------------------- # 

val=`expr 2 + 2`
echo -e "两数之和为：$val"

# 注意：
# 乘号(*)前边必须加反斜杠(\)才能实现乘法运算；

# --------------------------------------------------- #
# 关系运算符
# --------------------------------------------------- #
# -eq: 检测两个数是否相等
# -ne：检测两个数是否不相等
# -gt：检测左边的数是否大于右边
# -lt：检测左边的数是否小于右边
# -ge：检测左边的数是否大于等于右边
# -le：检测左边的数是否小于等于右边

a=10
b=10

if [ $a -eq $b ]; then
	echo -e "$a == $b"
fi

# --------------------------------------------------- #
# 布尔运算符
# --------------------------------------------------- #
# !：非运算符  [ ! false ] 返回true
# -o：或云算符
# -a：与运算符

c=20

if [ $a -eq $b -a $a -lt $c ]; then
	echo -e "$a == $b and $a < $c"
fi

# --------------------------------------------------- #
# 文件检测运算符
# --------------------------------------------------- #
# -b file：检测文件是否是块设备文件，是-true
# -c file：检测文件是否是设备文件，是-true
# -d file：检测文件是否是目录，是-返回true
# -f file：检测文件是否是普通文件（即不是目录，也不是设备文件），如果是，则返回true
# -r file：检测文件是否是可读，是-true
# -w file：检测文件是否是可写，是-true
# -x file：检测文件是否可执行，是-true
# -s file：检测文件是否为空（文件大小是否大于0），不为空-true
# -e file：检测文件(包括目录)是否存在，是-true

if [ ! -f README.md ]; then
    echo -e "exists ReadMe.md"
else
	echo -e "not exists file"
fi

if [ ! $USER = root ] && [ -f README.md ]; then
	echo -e "$USER"
fi

# --------------------------------------------------- #
# printf 输出
# --------------------------------------------------- #

printf "这是printf的输出\n"
printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.4

# 说明
# %s %c %d %f都是格式替代符
# %-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。
# %-4.2f 指格式化为小数，其中.2指保留2位小数。

# --------------------------------------------------- #
# 流程控制
# --------------------------------------------------- #

# if 语句：

# if condition
# then
#     command1
#	  command2
#     command3
# elif condition2
# then
#     command4
# else
#     command5
# fi
 
# for 循环：
# for var in item1 item2 ... itmeN
# do
#     command1
#	  command2
# done

for loop in 1 2 3 4; do
	echo "$loop"
done

for str in 'this is a string' 'name'; do
	echo "$str" "--"
done

echo "# for 的另外一种选择"

for((i=1;i<=5;i++));do
	echo "$i"
done

# while 循环
# while condition
# do
#	  command
# done

int=1
while [ $int -le 5 ]; do
	echo $int
	let "int++"
done

# 注
# until 循环执行一系列命令直至条件为 true 时停止。
# until 循环与 while 循环在处理方式上刚好相反

# case
# case 值 in
# 模式1)
#     command1
#     ...
#     ;;
# 模式2)
#	  command2
#	  ;;
# 模式3)
#	  command3
#	  ;;
# esac

echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac

# case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。

# 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。

## 跳出循环
# break 和continue

echo "# -------------------------------------------------- #"
echo "# 函数"
echo "# -------------------------------------------------- #"

# [ funciton ] funname [ () ]
# {
#	  action;
#     [return int;]
# }
# 说明
# 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
# 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255

function funWithReturn(){
	echo "计算两个数之和"
	echo "输入第一个数字"
	read aNum
	echo "输入第二个数字:"
	read bNum
	echo "$aNum + $bNum ="
	return `expr $aNum + $bNum`
}
# 函数返回值在调用该函数后通过 $? 来获得。
funWithReturn
echo $?

# 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。

# 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...

function funWithParam(){
	echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 10
# 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。

echo "# -------------------------------------------------- #"
echo "# 重定向"
echo "# -------------------------------------------------- #"

printf "%-20s %-20s\n" 命令 说明
printf "%-20s %-20s\n" 'command > file' 将输出重定向到file
printf "%-20s %-20s\n" 'command < file' 将输入重定向到file
printf "%-20s %-20s\n" 'command >> file' 将输出追加的方式重定向到file
printf "%-20s %-20s\n" 'n >& file' 将输出文件m和n合并
printf "%-20s %-20s\n" 'n <& file' 将输入文件m和n合并

# 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

# command > /dev/null

